- RDBS 란?
  - 공통된 속성(컬럼)을 공유하는 튜플(record,key)로 이루어진 테이블 
- INDEX
  - 사전의 인덱스와 동일(a,b,c 로 되어있는 순서)
  - b-tree 구조
  - primary key 에 해당되는 id 는 자동으로 인덱스가 생성되어있다
  - model 항목에 unique 를 주니까 index 가 생성되어있다.
  - 테이블의 정렬이 인덱스에 의해 되는 논리적 구성
    - 인덱스는 첫번째 컬럼의 값으로 구성된다(id, pk)
      - 이는 사전에서 a 가 인덱스로 구성되는 것과 동일한 원리(a를 기준으로 알파벳순서 정렬)
    - 인덱스의 첫번째 컬럼이 동일하다면 인덱스의 두번째 컬럼의 값으로 정렬된다. 
      - 사전에서 ab 로 시작되는 단어의 순서는 b 를 기준으로 정렬된다. 
  - 인덱스를 어느경우에 생성하는가?
    - 어떤 컬럼에 인덱스를 주냐가 아니라 해당 sql 이 인덱스를 이용해야하는가에 기준을 두어야 한다.
      - \1. 엑세스 하는 데이터의 양이 기준이 되어야 한다
        - 만약 많은양의 데이터를 해당 테이블에서 엑세스 하는 경우
          - 인덱스 엑세스를 한 후 테이블 엑세스를 하는 랜덤 엑세스가 발생하여 성능 저하 
            - 이와같은 경우라면 인덱스를 사용하지 않고 테이블을 엑세스 하는 것이 더 빠르다
          - 20페이지에 200개의 단어가 적힌 사전에서 10개의 단어를 찾을 경우, 인덱스를 이용해 찾는것이 빠른가? 아니다. 
            - 1페이지당 평균적으로 10개의 단어가있고 우리는 그 중 5개를 찾아야한다.
            - 인덱스를 이용하는 경우 한 페이지에 인덱스를 이용해 5번 엑세스하게된다.
            - 하지만 처음부터 한페이지씩 본다면 페이지당 한번만 엑세스하게 될 것이다.
      - \2. 테이블 전체 스캔을 해야하는 sql 을 제외하면 인덱스를 이용한다
        - 많은 양의 데이터의 기준은? 
          - 테이블의 3%~5%정도의 데이터를 넘게되면 전체스캔을 하는것이 낫다(인덱스사용 x)
    - 분포도가 결합인덱스의 성능을 보장하지 않는다
      - 인덱스 컬럼의 순서가 효과적이여야한다.
        - SELECT * FROM table WHERE col1 = 'a' AND col2 BETWEEN 'a' AND 'b' (col1 의 분포도 나쁨, col2 의 분포도 좋음)
          - 이 경우 col2 의 분포도가 좋기때문에 BETWEEN 연산자를 사용한 col2 를 먼저 사용하면 분포도는 의미가 없게된다.
          - = 연산자와 LIKE, BETWEEN 연산자의 차이가 분포도의 중요성을 좌우하는 것이다
          - 위의 SQL 의 최적 인덱스는 col1 + col2 가 되는 것이다.
          - 결국 점조건, 선분조건을 고려해 '연산자'에 의해 처리범위가 감소하게되는 것이다.

-  Transactions(처리/처리과정)

  - 데이터 베이스 충돌을 해결하기위해 DB 업데이트를 단일화된 작업으로 처리하는 기법

  - 예를 들어 a,b 를 수정한다고 하면 a는 수정했으나 b 는 실패한 경우 a, b 모두 수정 전 상태로 유지하는 것 

  - 하나의 트랜잭션이 완료되기 전에 다른 갱신 트랜잭션이 접근하지 못하도록 해야한다.

    

- 데이터 분포도

  - 1/겹치지 않는 값(컬럼에서) * 100 , 특정 row의 수/ 전체 row 수 * 100
  - 보통 10% ~ 15% 미만이면 좋은 분포도를 가지고있으며 index 사용에 적절하다고 한다.
  - 이때 중요한 것은 해당 row 가 어느정도의 row 를 차지하는가이다.  특정 컬럼의 분포도가 좋다고 해도 특정 row 가 같은 값을 많이 가지고있다면 index  를 사용하게되어도 row 의 양이 많이때문에 성능이 개선되지 않는다