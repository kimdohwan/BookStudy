

### 자료구조

- 연결리스트
  - 노드가 노드를 가르킴(노드는 data, link를 가짐)
  - 장 : 데이터 수정 시 이동이 필요 없다(link만 바꿔주면 된다, 배열의 경우 한칸씩 이동해야하는데)
  - 단 : 검색 시 앞쪽부터 노드를 거치므로 index 사용하는 array보다 비효율
- 스택
  - 한쪽 끝에서만 자료를 넣고 뺄수 있는 LIFO
  - pop(), push(), peek()
  - 사례: 재귀함수
- 큐
  - 자료를 넣고 빼는 출구가 다르다 FIFO
  - enqueue, dequeue
  - 사례: 프린터 문서 출력 대기시,  CPU의 연산 처리 작업 대기
- 트리
  - 하나의 루트노드를 갖고 노드들은 엣지를 가진다. 계층적 구조를 가짐 
  - 사례 : DNS 주소 검색, DB 자료 검색
- 해시 테이블
  - 해시란 가변길이의 데이터를 고정길이의 데이터로 매핑한 값
  - 해시 함수를 통해 변환한 값을 index로 해시 테이블에 저장한다 
  - 충돌 발생 상황: 같은 해시값을 가지는 경우
  - 충돌 해결방법 
    - 개방 주소방식 : 해시테이블의 열린 공간을 찾아 저장 
    - 폐쇄 주소 방식 : 충돌이 일어난 곳에 모두 저장, 연결리스트의 형태로 저장
    - 충돌 발생 시 다음항목으로 넘어가는 연산을(인덱스 처리) 어떻게 하느냐에 따라 방식이 다름
    - 예를들어 점프시퀀스에 해당하는 공식을 변화시킴
- 정렬
  - quick : 피벗값을 기준으로 작은값은 왼쪽 리스트에 큰 값은 오른쪽에 정렬 시킴. 리스트를 2개로 분할하는 방식 ( n로그n)
  - heap : 이진트리 형태를 가져 최대값과 최소값을 쉽게 추출 가능(시간 적게), 루트(첫번째)의 데이터와 마지막노드의 데이터의 값 비교 후 값 교환한다. 다음 힙크기를 감소시킨 후 다운힙을 통해 정렬을 해준다. 이 과정을 반복
  - 합병 : 분할 방식, 분할된 배열에서 정렬된 부분을 합하여 전체가 전렬된 리스트가 되게 함
  - 추가적인 리스트가 필요 
- 다익스트라
  - 네트워크 라우팅 프로토콜에서 최단 경로를 찾기위해 쓰임 
  - 노드와 간선으로 이루어짐. 간선은 가중치or비용이 있다
  - 가중치의 누적된 값을 구해 비교하는 방식으로 최단거리를 찾는다
- 깊이우선 너비우선
  - 깊이의 경우 노드가 가진 첫번째 간선을 계속 탐색하다가 더이상 없는 경우 두번째 간선을 탐색, 뒤로 돌아가며 두번째 간선 탐색하는 방식 
  - 너비우선의 경우 노드가 가진 모든 간선을 탐색한다. 

### REST

- 자원의 표현에 의한 상태를 전달, 즉 URI와 HTTP Method를 통해 자원(데이터)을 주고 받는 것

- 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나이다.

- URI -> 자원 / HTTP Method -> CRUD Operation

- JSON을 사용하는 이유

  - 다양한 언어에 의해 파싱될 수 있다.
  - xml이 아닌 jason인 이유 
  - 종료 태그를 사용하지 않는다.
  - Tag 구문을 쓰지 않기에 구문이 더 짧다(더 빠른 이유, 사용하기 쉽다.)
  - 배열을 사용할 수 있다.
  - html과 javascript와 연동되어 더 빠른 수행이 가능하다

### HTTP

- tcp/ip 프로토콜을 기반으로 작동하는 어플리케이션 프로토콜

 - Server와 Client 사이에 이루어지는 요청/응답 프로토콜 
 - www 상에서 정보를 주고 받을 수 있다. TCP/UDP 를 주로 사용하며 80번 포트 
 - 비연결성

    - Server와 Client 사이에 연결을 유지하지 않는 성질 
    - 소켓을 유지한다거나, 연결 유지를 위한 리소스를 줄일 수 있다.
 - 무상태성

    - 비연결성으로 인해 상태를 서로 기억할 수 없음
    - 이를 보완하기 위한 방법이 쿠키와 세션, 그외에 토큰 방식 등이 있다.
    - 쿠키와 세션의 차이점
       - 저장위치 - 클라이언트 / 서버
       - 저장 형태 - 키,밸류의 텍스트 형식 / Object형
       - 만료 기간 - 브라우져 종료 / 정확한 시점 X(클라이언트 측 반응 없거나 로그아웃이거나)
       - 용량 - 도메인당 20개 / 제한없음
       - 속도 - 쿠키가 빠름

 - 상태코드

    - 클라이언트 요청에 대한 서버의 응답의 처리 상태

### GET(가져오기) vs POST(수행)

- GET 방식 : 내용이 URL에 포함된다. 정적인 웹 페이지처럼 다룰 수 있음. 간단한 요청, 또는 보안이 필요 없는 요청에 사용.
- POST 방식 : 내용이 Body에 담긴다. 정보를 저장하거나 변경할 때 사용. GET 보다 더 큰 데이터를 전송

### TCP vs UDP

- tcp 
  - 연결 지향(소켓을 사용), 3wayhandshaking을 통해 연결 , 서버와 클라언트 1:1 연결
  - 데이터의 무결성을 보장하는 검사 수행, 신뢰성 보장 
  - 속도 느림(UDP보다)
- UDP
  - DNS가 사용 
  - 비 연결 지향, 단방향 통신, 소켓 대신 ip 프로토코를 기반으로 데이터 전송 , 1:다 통신
  - 신뢰성이 낮다, 속도가 빠르다, 
  - 실시간 스트리밍 서비스에 사용 

### 웹 서버 응답이 느리다면?

- 비효율적인 DB 쿼리
  - 해결법 : ORM이나 쿼리 수정을 통해 쿼리수 줄이기 
- 리다이렉트의 반복 - 불필요한 리다이렉트 지양
- http 요청의 수가 많은 경우(JS, CSS, 이미지 등 http 재요청 발생케 하는 것들) 
  - 해결법 : js, css 한 군데에 모으면 good 
- 쿠키 정보가 많은 경우
  - 해결법: 불필요한 세션/쿠키 정보 삭제
- 재사용이 잦거나 로드가 오래걸리는 부분
  - 해결법 : 캐시로 뺄수 있다면 빼준다
- CDN 사용(해외 서비스라면)
  - CDN은 사용자와 가까운 분산서버에서 CSS/JS와 같은 파일을 응답케 해줌

### OOP

- 절차지향처럼 함수단위로 순서대로 진행되는 것이 아닌 객체의 관계를 통해 프로세스를 진행시키는 방식

- 클래스 / 인스턴스 : 메서드와 속성으로 정의된 클래스를 실체화 시킨 것이 인스턴스
- 추상화 : 공통된 특징, 행동을 파악해 하나의 개념으로 다룬다(영희, 철수 -> 사람)
- 캡슐화 : 기능과 특성을 모아준다(클래스라는 캡슐에) / 응집도는 높게, 결합도는 낮게
- 상속 : 클래스 상속을 통해 특정 기능을 재정의/수정/재사용
- 다형성 : 같은 이름을 가진 메서드지만 다르게 동작

### RDBMS / NOSQL

- Table - 데이터들간의 관계를 나타낼 수 있다 
- Key / Value - 빠르고 더 큰 규모의 데이터를 다룰 수 있다

### ORM 을 효율적으로 작성하기

- foreign key
  - all() 로 불러오는 것이 아니라 objects.select_related('key').all() 로 불러오기
- many to many
  - prefech_related()
- values(), value_list()
  - 객체가 필요하지 않은 경우, 값만 필요한 경우
- difer(), only()
  - 사용하지 않는 컬럼은 가져오지 않는다. only() 는 사용하는 컬럼만 가져옴
- exists(), count()
  - 'if 쿼리셋' 이 아닌 if 쿼리셋.exists() 를 사용하자

### 